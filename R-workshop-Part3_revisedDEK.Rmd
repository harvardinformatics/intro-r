---
title: "[Workshop] Introduction to R Part 3: ggplot"
description: "An introduction to data visualization in R with ggplot."
date: "October 25 & 27, 2023"
authors: 
  - Adam Freedman
  - Tim Sackton
  - Gregg Thomas 
  - Lei Ma
output: 
  html_document:
    keep_md: true
---

# Introduction to R Part 3: ggplot

Welcome to the Part 3 of the [FAS Informatics :material-arrow-top-right:](https://informatics.fas.harvard.edu/){:target="_blank"} Intro to R workshop! 

If you're viewing this file on the website, you are viewing the final, formatted version of the workshop. The workshop itself will take place in the RStudio program and you will *edit and execute the code in this file*. Please download the raw file [here :octicons-download-24:](R-workshop-Part3-student.Rmd).

## Data visualization in R with ggplot2

Conveying research findings in a meaningful way is an integral part to being a scientist, almost as important as performing research itself. The scale of modern biological data compounds its importance -- we now need to summarize and condense millions of data points into meaningful, easy to understand figures while still showing the scale and variance in our data. All of which leads to the need for scientists to be able to programmatically generate visualizations for exploratory analysis, to convey conclusions, and for reproducibility of final figures.

In addition to statistical analysis, the R programming language and the RStudio IDE are built for this task, and while many people are able to generate figures with these programs, there can be a steep learning curve. The goal of today's workshop is to introduce you how to use the skills you've learned in the previous workshops to manipulate data and visualize it in RStudio. We'll touch a little bit on plots that can be generated by R itself (referred to as "base R"), but spend much of the time showing you the tidyverse plotting package, ggplot.


## Introduction to ggplot (FROM REVISED)

[ggplot :octicons-link-external-24:](https://ggplot2.tidyverse.org/){:target="_blank"} is a **package** (library of code with various functions) that is part of the **tidyverse**. It uses a somewhat standardized 'grammar of graphics' ([book :octicons-link-external-24:](https://id.lib.harvard.edu/alma/990082021020203941/catalog){:target="_blank"}; [paper :octicons-link-external-24:](https://hollis.harvard.edu/permalink/f/1mdq5o5/TN_cdi_informaworld_taylorfrancis_310_1198_jcgs_2009_07098){:target="_blank"}) in its syntax to make almost every aspect of a plot customizable. The input to ggplot are **data frames** and **tibbles**, and the best way to organize your data so that it is easily plotted is by ggplot is following the **tidy** principles, which is why it's part of the tidyverse.

If you haven't already, download and install the tidyverse bundle of packages and load it. ggplot2 is one of the packages bundled with it. We'll also install and load the `palmerpenguins` package, which contains the sample dataset we're working with.

Do so by running this code block (by clicking the green triangle in the upper right, or by placing the cursor in the code block and using *ctrl+enter*/*cmd+enter*.)

```{r, message=FALSE, warning=FALSE}

installed_packages <- rownames(installed.packages())

for (pkg in c("tidyverse", "palmerpenguins")) {
  if (!pkg %in% installed_packages) {
    install.packages(pkg, quiet = TRUE)
  }
  library(pkg, character.only = TRUE)
}
```

As noted above, we're going to be working with the `penguins` data set. This is a dataset of mixed data, meaning some variables are categorical and some are numerical, collected about penguins at a research station. It is organized so that each row is a single penguin and each column are the measurements taken of the penguins. You can view the data set by running the following code block:

```{r}
glimpse(penguins)
```

## Building a basic plot: aesthetics and layers (FROM REVISED)

What goes into constructing a plot? Let's begin by going over two important concepts of ggplot: **aesthetics** and **layers**.

As described in the [official ggplot2 handbook](https://ggplot2-book.org/){:target="_blank"}, every plot consists of:
| 1. **data**
| 2. A set of **aesthetic mappings** between variables in the data and visual properties of the plot
| 3. At least one **layer** that describes how to render each observation

Let's start from the top! A ggplot starts by defining a graphical object (or **grob**) with the `ggplot()` function and telling it the source of the data for the plot, like this:

```{r}         
ggplot(penguins)
```

This is the **data** we want to plot. However, in the above example, only a grey box is displayed. This is because, while we've told ggplot *which* dataset to use (`penguins`), we haven't told it what *parts of the data* to plot yet. To do so, we need to specify the variables to plot along each axis as **aesthetics**.

For example, if I wanted to plot two columns from the `penguins` dataset called `bill_length_mm` and `bill_depth_mm` that I wanted to use in my plot, I would do the following:

```{r}         
ggplot(penguins, aes(x = bill_depth_mm, y = bill_length_mm))
```

Now, it looks like we have added axes on our white box, but nothing else. At this point, we've told ggplot the dataset to use (`penguins`) and which parts of that dataset to use (`bill_length_mm` and `bill_depth_mm`), but now *how* to display the data.

We need to tell ggplot how to interpret the aesthetics as a graphical representation, i.e. do we want points, lines, bars, etc. We do this by adding **layers** onto the plot with the `+` operator. Each `+` indicates a new layer in the specified ggplot object and many layers can be added to a single plot in order to display the data in different ways. In general, layers can either *display the data*, display a *statistical summary* of the data or *add additional metadata* (context, annotations, etc) to the plot. The layer we add when telling ggplot how to plot the aesthetics (data) is usually called a **geom** (short for geometry).

There are many types of geoms depending on what relationship you are trying to plot. A list of geoms can be found [here :octicons-link-external-24:](https://ggplot2.tidyverse.org/reference/#geoms){:target="_blank"}. For example, let's say we want to visualize the distribution of the penguins' body mass. Single distributions are typically plotted as histograms or density plots. So to generate the histogram, we would follow these steps:

1.  Specify the dataset (in our case, `penguins`)
2.  Identify the variables in the dataset to plot and specify them as aesthetics. This will require you to look at your data! For our first example, it will be `body_mass_g`
3.  Add a geom layer with the `+` operator that tells ggplot how to display the specified data:

Here's what that looks like. Run the following code block:

```{r}
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram()
```

A great feature of ggplot is that it does calculations and data transformations for you under the hood. In this code, we only specified that we want the x axis to be body mass and `geom_histogram()` automatically inferred that we want the counts of the body mass to be plotted on the y. It also calculated how wide each bin should be given a default bin number of 30.

Importantly, each layer itself is a function that can take **arguments** (or **parameters**/**options**) as input within the `()` to further customize how the data is handled and displayed. For example, `bins` and `bindwidth` are parameters you can give to the geom_histogram() function to customize the calculations ggplot does under the hood.

Let's use this information to now plot a histograms of the penguin `body_mass_g` variable with different bin parameters:

```{r}
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth=50)
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(bins=10)
```

## Exploring other geometries (NEW)

So far, we've only looked at a single type of plot, `geom_histogram`, but there are many more option in `ggplot`, and even more in the various add-on packages to `ggplot`! Let's look at another plot type you are likely familiar with, the scatterplot, which uses `geom_point`.

> **Exercise**
> In the code block below, using the same aesthetics we used for the histogram, use `geom_point` to draw a scatterplot:


```{r}
ggplot(penguins, aes(x = body_mass_g)) +
  geom_point()
```

OK, what is going wrong here? If we look at the error message, we can see that we are missing an **aesthetic** property; unlike with `geom_histogram`, which only requires a single variable (the `x`), `geom_point` requires both an `x` and a `y`...which makes sense, as scatterplots are all about comparing two variable against each other, while a histogram shows the distribution of a single variable.

Let's pick another variable from our penguins dataset, `bill_length_mm`.
> **Exercise**
> In the clode block below, plot a scatterplot showing the distribution of body mass vs bill length:

```{r}
ggplot(penguins, aes(x = body_mass_g, y = bill_length_mm)) +
  geom_point()
```


NOTE: ADD MORE TO THIS SECTION!

> Exercise: pick a geom from the ggplot site and adapt it to our penguin data


### Adding new data to a ggplot (NEW)
We know that a `ggplot2` plot requires at least one **layer** (i.e. a **geom** function), but because of `ggplot2`'s modularity, it can take multiple **geom** layers in a single plot.

To explore this, if we "eyeball" the scatterplot we just made showing beak length by body size, we can maybe see that there is a relationship between the two variables

> **Exercise**
> Look up the `geom_smooth` function, then add it to the scatterplot to plot a linear fit line to our data (using just the default settings for `geom_smooth`)

```{r}
ggplot(penguins, aes(x = body_mass_g, y = bill_length_mm)) +
  geom_point() +
  geom_smooth()
```

Nice, we can see much more clearly that bill length is correlated with mass!

Certain `geoms` won't make sense to combine together in a single plot, and others may have **aesthetic mappings** that are incompatible with one another. That raises the question, how exactly are **aesthetic mappings** shared by different layers? Let's explore that next!


### Mapping vs setting aesthetics (FROM REVISED)

Different **geoms** have different visual properties (aesthetics) that can be assigned to variables. Here's a list of the most common properties. Underlined are the ones that are valid for this `geom_histogram()`:

-   [color]{.underline}: this changes the color of the line or points
-   [fill]{.underline}: if the shape is filled, this changes the fill color. Filled shapes are used in bar plots, box plots, and histograms. Points are generally not filled.
-   shape: if your geom is a point, this changes the shape of the point. (Some shapes are filled, some aren't)
-   size: this changes the size of the point or line
-   [linetype]{.underline}: If the geom has a line, including if it's an outline, this changes the type of line (dotted, dashed, etc)
-   [alpha]{.underline}: this changes the transparency of the geom

Let's change some of the mapping properties of the histogram plot we made by using these aesthetics inside the `geom_histogram()` function:

```{r}
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(color = "black", fill = "blue", linetype="dashed", alpha=0.6)
```

In the above code, we used aesthetic mappings to change the visual properties of all the histogram bars at once. This is called **setting** the aesthetic property. Another thing we can do is **mapping** the aesthetic property to a variable in the data. This is done by putting the aesthetic inside the `aes()` function. This is useful when you want to color the bars by a variable in the data, like the species of the penguin:

```{r}
ggplot(penguins, aes(x = body_mass_g, fill = species)) +
  geom_histogram(color="black")
```

In the above code, we have **mapped** the fill aesthetic to the species variable in the data. By mapping an aesthetic property to a variable, the bars are colored by that variable and ggplot automatically generates a legend that matches.

Also notice how we have **set** the color of the outline of all the bars to be black. This is because the color aesthetic is not placed inside the `aes()` function, so it applies to every piece of data. Here's what happens if you put `color="black"` inside the `aes()` function:

```{r}
ggplot(penguins, aes(x = body_mass_g, fill = species, color = "black")) +
  geom_histogram()
```

And here's what happens when I try to put `fill=species` outside of the `aes()` function.

```{r error=TRUE}
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(color="black", fill=species)
```

R is throwing an error because it is only inside the `aes()` function that you can directly reference a variable in the data.

To sum, in this section, we learned that you can set an aesthetic property to be constant across all data by putting it outside the `aes()` function or you can map it to a variable by putting it inside. Later, we will learn that you can override the aesthetic by putting an `aes()` function inside the `geom` function.


### Inheriting aesthetics (FROM REVISED)

But first, we'll see how we can add another geom layer to the plot.

In the below code, we will display data as a scatter plot using `geom_point()` layer. Since scatter plots require an x and y axis, in our `aes()` call we'll have to specify both. Let's compare the penguins' body mass with their bill lengths. We used `body_mass_g` and bill length is stored in the `bill_length_mm` column of our data. We will also add another geom layer, `geom_smooth()`, which is a function that will calculate and add a linear fit to the points.

```{r}
ggplot(penguins, aes(x = body_mass_g, 
                     y = bill_length_mm, 
                     color=species)) +
  geom_point() +
  geom_smooth(method = "lm", se=FALSE) ## add linear fit, without confidence interval
```

You can see that the linear fit is done to each species separately. This is because geoms by default **inherit** the aesthetics (and the data) from the `ggplot()` function. This is a very useful feature of ggplot that allows you to easily add layers to your plot without having to specify the data and aesthetics again.

What happens when we put the `aes(color=species)` inside the `geom_point()` function?

```{r}
ggplot(penguins, aes(x = body_mass_g, y = bill_length_mm)) +
  geom_point(aes(color=species)) +
  geom_smooth(method = "lm", se=FALSE)
```

In the above figure, now the `geom_smooth()` function ONLY inherits the x and y aesthetic options and knows nothing about the species, which is why you only see a single linear fit across all the data. When you are layering multiple geoms together, you can more finely control how the aesthetics are mapped by putting them inside the `geom` function.

To sum up this section, we learned that you can layer geoms on the same graph to show different relationships in the data. Each geom can inherit the aesthetics from the `ggplot()` function, but you can also override these aesthetics by specifying them in the `geom` function.

Here's some vocabulary to tie it together:

| Term/Function | Definition/Description                                                                               |
|---------------------|---------------------------------------------------|
| tidy data     | Data where variables are in columns and observations are in rows. Easiest for plotting               |
| `ggplot()`    | Function that initializes a ggplot object                                                            |
| `aes()`       | Function that specifies the aesthetics of the plot                                                   |
| aesthetics    | Graphical properties governing how the data is displayed/mapped, e.g. x, y, color, fill, shape, etc. |
| `geom_*()`    | Function that specifies the type of plot to be drawn                                                 |
| layer         | A layer is a function that adds a new element to the plot, such as labels or new geoms               |
| `+`           | Operator that adds a new layer to a ggplot object                                                    |
| map/mapping   | Make an aesthetic property of a plot dependent on a variable in the data                             |
| set           | Make an aesthetic property of a plot constant                                                        |


## Customizing non-data aspects plots: lab(el)s, scales, and themes (FROM REVISED)

We've now learned how to use the `aes()` function to control how are variables are represented in the plot. Each geom has a set of aesthetics that can be mapped to the data or set as constant across all the data in the plot. By default, the ggplot package decides everything else about the plot, such as the axis labels, the colors, the background color, the legend position and size, etc. However, you can customize all of these things. The tricky part is knowing what kind of function to use to customize each aspect of the plot.

Here is the big design principle behind ggplot:

> **A ggplot (the object) is composed of data elements and non-data elements, and the key to figuring out how to change something is identifying whether that thing depends on the data or not.**

Let's define some terms:

A **data element** is something that was drawn onto the plot that is directly based on the data. These include things we've already talked about like:

-   bars in a bar plot
-   points in a scatter plot
-   all the aesthetic mappings of the geoms (shape, color, etc)
    -   everything about them, including the labels, the values, the order

But it also includes more subtle things like:

-   the labels on the tick marks of x and y axes and their order
-   the location of the x and y tick marks
-   the exact icon that the legend uses
-   the content of the text of the labels in the legend

A **non-data element** is something that is not directly based on the data, but is still part of how the plot looks visually. These include things like:

-   the font, font size, color, etc of text labels
    -   (except when you're plotting text with `geom_label`/`geom_text`)
-   the background color of the plot panel
-   the grid marks in the plot panel
-   the position of the legend
-   whether a legend appears at all
-   the position of any of the axis labels (both ticks and titles)
-   whether the axis lines are drawn at all
-   the margins of the plot
-   so much more!

The reason why understanding the difference between data and non-data elements is important is because there are different sets of functions that control each of these things. We are not going to cover every set of functions that governs visual appearance in ggplot, but hopefully by understanding this concept, when you see new code "in the wild", you will be able to understand how that worked and then make it your own.

In this next section, we will go through the steps to recreate a more complex plot. There will be BONUS sections that I will skip, but are in the text for your own reference later to expand on the function we introduce.

Often, we have an idea in our minds about what we want the graph to look like. For example, let's pretend this is what we want our graph to look like:

#### Example plot

![](img/palmer_penguins.png)

#### Base plot

Right now, this is our code based on what we've learned so far about mapping and setting aesthetics and layering geoms. We know where to put the `color` aesthetic and where to put the `shape` aesthetic, and how to prevent the legend from `geom_smooth` from showing. From a data perspective, all the same information is there, but it just looks not so great.

So, since we want to experiment, we can save this plot to an object with the syntax `g <- ggplot()` . This creates an object called `g` in our environment that contains all the information to recreate this base plot. The nice thing is, as we will see, you can directly add layers with `+` to the plot object `g` as you experiment with changing the visual elements.

```{r}
g <- ggplot(data=penguins, aes(x = bill_length_mm, 
                               y = bill_depth_mm, 
                               color = species)) + 
  geom_point(aes(shape = species)) +
  geom_smooth(method = "lm", se = FALSE, show.legend = F)
g
```

#### Base plot with labels

The first thing we want to do is to add a title, subtitle, x an y axis labels, and also a better legend title. All this can be accomplished with another layer called `labs()`. In the below code block, we are using our saved ggplot object called `g` from above so we don't have to type everything again to create the base plot. Using `g + blah()` allows us to add another layer without modifying the base plot.

Notice how we added a title to the `color` aesthetic and it separated out that aesthetic from the `shape` aesthetic! This is because now `shape` and `color` now have two different names, one derived from the data and one provided by the `labs()` function.

```{r}
g + 
  labs(title = "Penguin bill dimensions",
       subtitle = "Bill length and depth for Adelie, Chinstrap and Gentoo Penguins at Palmer Station LTER",
       x = "Bill length (mm)",
       y = "Bill depth (mm)",
       color = "Penguin species")
```

To fix this, we need to set both aesthetics to the same name. We could save this as our new base plot, but as we'll see later, the order of how we add layers matters, so we'll hold off for now.

```{r}
g + 
  labs(title = "Penguin bill dimensions",
       subtitle = "Bill length and depth for Adelie, Chinstrap and Gentoo Penguins at Palmer Station LTER",
       x = "Bill length (mm)",
       y = "Bill depth (mm)",
       color = "Penguin species",
       shape = "Penguin species")
```

#### Adding color scale

Let's keep working from the base plot. The next major difference between our current plot and our ideal plot that we're going to tackle is the color, transparency, and the size of the shapes. All of these are aesthetic qualities, which mean it is about how the data are presented. So we'll need to modify the `geom` function and use a new type of function called a `scale` function. First let's modify the `geom_point` to change the size and transparency of the points.

Remember that due to inheritance, we will need to re-specify that we want the geom_point's `aes` to assign `shape=species`. Also we will be setting the size and transparency (aka **alpha**) for all points so it goes outside the `aes` .

```{r}
g + 
  geom_point(aes(shape=species), size=3, alpha = 0.8)
```

Now what about the difference in color? We can use a function of the class `scale_color_*`. The `scale_*_something` functions are a class of functions that customize how aesthetics are mapped. The word after scale is the aesthetic you want to customize and the third word is usually either `continuous/discrete/manual/brewer` depending on whether you are plotting a numerical or categorical variable or whether you want full control over everything. So you can have `scale_fill_manual()` to manually map the fill aesthetic, `scale_color_discrete()` and `scale_color_continuous()` to map discrete or continuous values from your variable onto a color scale, etc.

R has built-in color names and that we can input that to `scale_color_manual`. There are 657 built in color names in R. You can see a list of them using the `colors()` function, type `demo("colors")` for an interactive tour of all of them, or simply search for an image of all the colors online. For now, we will cheat and I will provide that the original plot was made with the colors "darkorange", "purple" and "cyan4". These can be entered in order to the `values` parameter of `scale_color_manual`.

```{r}
g + 
  geom_point(aes(shape=species), size=3, alpha = 0.8) +
  scale_color_manual(values = c("darkorange", "purple", "cyan4"))
```

BONUS: Read about pre-made color palettes

We can use `scale_color_brewer` to take advantage of pre-made discrete color palettes. To see all the options type `RColorBrewer::display.brewer.all()` in your console. For more information on how to generate custom palettes, use rgb values to specify colors, and more, see chapter 12 "Using Colors in Plots" in the [R Graphics Cookbook :octicons-link-external-24:](https://r-graphics.org/CHAPTER-COLORS){:target="_blank"}.

```{r}
g + 
  geom_point(aes(shape=species), size=3, alpha = 0.8) +
  scale_color_brewer(palette = "Dark2")
```

BONUS: Read for more things you can control with scales for aesthetics

The other things you can change in `scale_color_manual` is how each color is mapped to each discrete value and also how each discrete value is labeled. We can explicitly set key:value pairs inside this to control which penguin gets which color. The keys must be how they are stored in the data. But if how they are stored in the data is not what we want to display, like common name instead of scientific name, we can then label these penguins whatever we want using the `label` parameter.

```{r}
g + 
  geom_point(aes(shape=species), size=3, alpha = 0.8) +
  scale_color_manual(values = c("Chinstrap"="darkorange", "Adelie"="purple", "Gentoo"="cyan4"), labels = c("Chinstrap"="P.antarcticus", "Gentoo"="P.papua", "Adelie"="P.adeliae"))
```

#### Adding X/Y axis scale

One of the other differences between what we have now and the example plot are the X and Y axis tick marks. You will notice that in the example plot, there are many tick marks on the Y axis and a few additional ones on the X axis as well. Is this element of the plot a data-driven visual element or a non-data element?

If you guessed data-driven, you are correct! The spacing (or, **scaling**) of X and Y axes is typically automatically decided by ggplot based on the distribution of your data. This is how you always end up with a plot that shows all your data and not a ton of empty space to either side.

The way we can customize the X and Y axis scaling is with the set of functions `scale_x/y_something`. The "something" can be a transformation, like `log10`, or `continuous()`/`discrete()`. We are plotting continuous variables on both axes so we will use `scale_x/y_continuous()`

The arguments for these functions include

-   name: another way to set the axis label

-   breaks: the positions where there will be tick marks and text labels

-   n.breaks: alternatively, tell ggplot how many breaks you want

-   labels: how you want to label the tick marks

-   limits: the min and max value of the axis

The below code demonstrates how to manually set the breaks and limits for the x axis to match the example plot. We use `seq()` to create a vector of numbers from 30 to 60 with a step size of 10. Those are the breaks - where the tick marks will be. We also make sure that the limits include those breaks, as the base plot had slightly narrower x limits.

```{r}
g + 
  scale_x_continuous(breaks=seq(30,60,10), limits = c(30,60))
```

In the code block below, we will use the `n.breaks` argument in `scale_y_continuous` to add the number of breaks we want without having to manually create them. Now our axes look just like the example!

```{r}
g + 
  scale_x_continuous(breaks=seq(30,60,10), limits = c(30,60)) +
  scale_y_continuous(n.breaks = 10)
```

BONUS: scaling the axes works for discrete values as well

There are many more options for the scale functions. You can even use them with discrete variables to change the order of the labels or the colors of the bars. Here's an example of how you can change the order of the species in the legend. In the below code, I reordered the bars and also used the `position` argument to move the x axis to the top of the plot.

```{r}
ggplot(penguins, aes(x = species, fill=species)) +
  geom_bar()

ggplot(penguins, aes(x = species, fill=species)) +
  geom_bar() +
  scale_x_discrete(limits = c("Chinstrap", "Gentoo", "Adelie"), position ="top")
```

#### Base plot with all data elements

In the last sections we learned how to use `labs()`, `scale_color_manual()` , and `scale_x/y_continuous()` to affect change on the visual elements of the plot that depend on data. Let's put those together and see how close we are to the example plot.

```{r}
g + 
  geom_point(aes(shape = species),
             size = 3,
             alpha = 0.8) +
  scale_color_manual(values = c("darkorange","purple","cyan4")) +
  scale_x_continuous(breaks=seq(30,60,10), limits = c(30,60)) + 
  scale_y_continuous(n.breaks=10) + 
  labs(title = "Penguin bill dimensions",
       subtitle = "Bill length and depth for Adelie, Chinstrap and Gentoo Penguins at Palmer Station LTER",
       x = "Bill length (mm)",
       y = "Bill depth (mm)",
       color = "Penguin species",
       shape = "Penguin species")
```

![](img/palmer_penguins.png)

#### Theme

The remaining differences between this plot and our current plot are all due to the **non-data elements** of the plot. These include: the italicized font of the subtitle, the background color of the plot panel, the position and color of the legend. All these non-data elements can be edited using the `theme()` function.

Themes govern practically everything that isn't about how your data is presented, and it can be hyper-specific. For example, here is a diagram of the most common theme elements covering things you would never have thought could be customized. Changing an element of a plot generally entails first finding out what it is called in the theme. This is definitely **NOT** something you need to memorize.

![](https://isabella-b.com/blog/ggplot2-theme-elements-reference/ggplot2-theme-elements-reference-v2_hu8994090e1960a0a71878a3756da20076_580819_2000x2000_fit_lanczos_2.png)

In the below code, we've assembled all of our previous layers and added on the theme elements that need to be changed to create, finally, the look of the example plot. The adjustments made are:

-   place the legend inside the plot panel

-   adjust position of inside legend to the lower right

-   italicized the plot subtitle

-   changed the plot panel background color to "linen"

-   removed the default white legend background color (you'll see what this means if you remove this line)

```{r}
g_final <- ggplot(data = penguins, 
       aes(x = bill_length_mm,
           y = bill_depth_mm,
           color = species)) +
  geom_point(aes(shape = species), 
             size = 3, 
             alpha = 0.8) +
  geom_smooth(method = "lm", 
              se = FALSE, 
              show.legend = FALSE) +
  scale_color_manual(values = c("darkorange","purple","cyan4")) +
  scale_x_continuous(breaks=seq(30,60,10), 
                     limits = c(30,60)) + 
  scale_y_continuous(n.breaks=10) + 
  labs(title = "Penguin bill dimensions",
       subtitle = "Bill length and depth for Adelie, Chinstrap and Gentoo Penguins at Palmer Station LTER",
       x = "Bill length (mm)",
       y = "Bill depth (mm)",
       color = "Penguin species",
       shape = "Penguin species") +
  theme(legend.position = c(.85,.15),
        plot.subtitle = element_text(face= "italic"),
        plot.subtitle.position = "plot",
        plot.title.position = "plot",
        panel.background = element_rect(fill="linen"),
        legend.background = element_blank())
g_final
```

BONUS: Read about how you can change the look of the whole plot with just one line

ggplot has many built-in complete themes that overhaul plots to look differently. Here's a few of them. See how the same plot can look really differen by just picking a bundled theme.

```{r}
g_final + theme_dark()
g_final + theme_minimal()
g_final + theme_void()
```


### Saving ggplots (FROM ORIGINAL)

Now that we've made a pretty ggplot with tidy code, how do we save it to share with others? There are a few ways. 

The first way - if you've been working on your project in an rmarkdown document - you don't have to do anything! You can `knit` the rmarkdown document into HTML and share all the text, code, and images, without changing a thing. 

The second way is to use the RStudio GUI. Open the panel on the lower right containing the tabs Files/Plots/Packages/Help/ etc tabs and click on the plots tab. Then copy and paste the code you used to generate the plot (or in our case just the name of the object `iris_plot`) into the console, and the plot will show up there. Then, you can click the export button and save the plot. This is great if you want to throw something into powerpoint or share on slack/email with a collaborator your intermediate results. 

However, if you want to save a plot for publication and then also intend to publish the code used to generate that plot, the best practice is to use an R Script, copy and paste all (and only) the code you used to generate the final plot, save it, and then use the `ggsave()` function to export your plot. Open a new R script now and copy ALL the code you used to generate the latest plot. This includes importing the tidyverse and datasets package, transforming the iris data, and of course the plotting code itself. Then, use `ggsave()` to save the plot using the default parameters.

> **Exercise**: Open a new R script (should have a .R extension) to reproduce the final, beautiful penguin plot we just made in the last code chunk by copy and pasting the necessary code. Then, use `ggsave()` to save the plot using the default parameters. To really check that your code is standalone, **clear your environment** and run the script. If it works, you're good to go!


## Plotting multiple plots in one window with facetting (NEW/FROM ORIGINAL)

In almost any scientific paper you will see figure with multiple panels, with subsets of plots split by some categorical variable (e.g. "treatment" vs "control" etc.) The coward's route is to make the plot individually, then combine them in Powerpoint or Illustrator, but there is no need! `ggplot2` provides an easy way to compare groups in different panels called **facetting**. `facet_wrap()` and `facet_grid()` allow you to split your plot into multiple panels by another group variable. For our purposes, `facet_wrap()` is more useful, so we will focus on that.

We specify a variable in our **data** with the syntax `facet_wrap(~variable)` and `facet_wrap` will split the *same* overall data set into facets based upon grouping variables that subdivide the data so you can compare and contrast patterns in different groups (or pairs of groupings). For example, if we go back to our scatterplot showing bill length vs body size and say we want to split the data based on the sex of the birds:

```{r}
ggplot(penguins, aes(x = body_mass_g, y = bill_length_mm)) +
  geom_point() +
  geom_smooth() + 
  facet_wrap(~sex)
```

NOTE: FILL THIS SECTION OUT MORE

> **Exercise**
> Something splitting by species??


## Exploring different plot types (NEW/FROM ORIGINAL)
So far we have looked at scatter plots and histograms, but there are a TON of different `geoms` in `ggplot2`, and many other `R` packages that add `geoms` that use the `tidyverse/ggplot2` grammar. To get familiar with syntax, as well as reading documentation, let's do a few exercises where we plot the penguins in a number of different ways.

> **Exercise**
> Draw a *violin plot* showing distribution of body mass on each island. Color by species and use a theme of your choice.

> **Exercise**
> Use a *bar plot* to count the NUMBER of each different species of bird in the dataset (hint: check the `stat` argument).

------

## Integrating ggplot2 and tidyverse (NEW/FROM ORIGINAL)

### Cleaning untidy data
So far, we've been working with a nice, clean dataset that is already in an ideal arrangement for visualization with `ggplot`. Unfortunately, out in the wild data usually does not look like this. Let's check out the seedy underbelly of the penguins dataset and look at the RAW data:

```{r}
glimpse(penguins_raw)
```

We can see this is much messier...we have columns we aren't interested in, inconsistent column naming (with spaces in the column labels!!), extra text in the species labels...

Even though we technically already have the cleaned up version of the data, let's practice using tidyverse to take the raw dataset to a tidy, easy-to-plot version! First, let's break down what we need to do:

| 1. Only keep the 8 columns `Species`, `Island`, `Culmen Length [mm]`, `Culmen Depth [mm]`, `Flipper Length [mm]`, `Body Mass (g)`, `Sex`, `Date Egg`
| 2. Standardize and clean up the column names: make all lowercase, replace spaces with `_`, change `Culmen Length [mm]` to `bill_length_mm`, `Culmen Depth (mm)` to `bill_depth_mm`, `Flipper Length (mm)` to `flipper_length_mm` and `Body Mass (g)` to `body_mass_g`
| 3. Make sure all values in the `sex` column are lowercase
| 4. Turn the `Date Egg` column into `year` and make human-readable

There are many ways you could accomplish each of these...some of the relevant functions we have covered in previous sessions, but others you will have to look up! Here are the functions you'll need:

```
mutate()
tolower()
rename()
select()
word()
year()
```

One more thing: `tidyverse` (and `R` in general...) is very particular about column names containing certain special characters like **white spaces**. For instance, in your code if you had something like:

```
bill_length_mm = Culmen Length (mm)
```

You would get an error if you tried running this, as `R` thinks you are *trying to access a function called `Length`*! Getting into exactly how `R` handles this is a bit too much detail, so **tl;dr if you are referring to a column with a white space in it, use the backtick marks (the ` character) around it, e.g.:

``Column With Spaces``

You can now also hopefully appreciate exactly why we are renaming the columns to remove white spaces! :)

> **Exercise**
> Use tidyverse to convert the `penguins_raw` dataset to a cleaned up version called `penguins_cleaned` (which should be identical to the `penguins` dataset). Work together as needed!
> BONUS: improve the dataset even further and add code to remove any rows that contain `NA` values in any of the columns

```{r}
penguins_cleaned <- penguins_raw %>%
  rename(
    bill_length_mm = 'Culmen Length (mm)',
    bill_depth_mm = 'Culmen Depth (mm)',
    flipper_length_mm = 'Flipper Length (mm)',
    body_mass_g = 'Body Mass (g)',
    island = 'Island'
  ) %>%
  mutate(species = word(Species, 1)) %>%
  mutate(year = year(`Date Egg`)) %>%
  mutate(sex = tolower(Sex)) %>%
  select(species, island, bill_length_mm, bill_depth_mm,
         flipper_length_mm, body_mass_g, sex, year) %>%
  drop_na()
```


### Grouping and summarizing data and plotting
Now that we are back where we started, let's look at some of the other ways `tidyverse` can help us when making plots. Often when analyzing our data, we will want to generate summary statistics for various groups of observations. In a previous workshop we discussed the `tidyverse` functions `group_by()` and `summarize()`, which can help us do just that!

To review, to use `group_by()` we specify one or more variables (i.e. columns) in our tibble that we want to use to define the groups in our data. We then pass the grouped data to `summarize()` and apply a function (which can be built-in `R` functions like `mean` or our own custom ones) to each group, outputting a summary. We can either save this summary to a new tibble, OR we can feed it straight into `ggplot`! 

For example, rather than plotting a distribution, let's say we want to make a bar plot that shows the AVERAGE body mass of male vs female penguins.

> **Exercise**
> Using what we learned in previous classes, create a new tibble that summarizes the average mass of male vs female birds. Use that new tibble with `geom_bar` to plot.

> **Exercise**
> Now summarize average body mass by sex AND species, and make a dodged bar chart of the averages. Color the bars by species.

> **Exercise**
> Rather than dodging the bars, instead use `facets` to split the averages by species into male and female panes. Use a theme that looks nice.


Let's discuss some more advanced things you can do with `group_by/summarize` and `ggplot`. Often times it is useful to add summary statistics to our plots, which we can accomplish using the methods just mentioned and *combining layers* in `ggplot`. First, let's make a histogram showing distribution of bill length, grouped by species:

```{r}
ggplot(penguins_cleaned, aes(x=bill_length_mm, fill=species)) +
  geom_histogram() +
  theme_classic() +
  facet_wrap(~species, ncol=1)
```

We'll then create a summary tibble with the mean bill length per species using `group_by` and `summarize`:

```{r}
mean_bill_length <- penguins_cleaned %>%
  group_by(species) %>%
  summarise(mean_bill_mm = mean(bill_length_mm))
```

We can then add a *reference line* to each histogram indicating the mean of the distribution by combining layers, i.e. adding another `geom` to the plot. If we think back to how `ggplot` works with inheriting aesthetics, because we are using a different **data** source (i.e. the summary tibble we just made), we'll need to specify it in the **aesthetic** for the new `geom` layer.

```{r}
ggplot(penguins_cleaned, aes(x=bill_length_mm, fill=species)) +
  geom_histogram() +
  theme_classic() +
  facet_wrap(~species, ncol=1) +
  geom_vline(data=mean_bill_length, aes(xintercept=mean_bill_mm), color = 'grey', linetype = "dashed")
```

Note that when specifying the color and type of the line, because of how aesthetics work we need to put them *outside* of the **aesthetics**.


### Extending plotting functionality
Since we are combining layers in our plots, let's use that as an opportunity to check out some external packages that can build on `ggplot` and add some features that it does not support natively. One very common plot feature you will see in published figures is sets of brackets indicating whether two groups in the data are significantly different from one another, as determined by some statistical measure (T-test, Mann-Whitney U test, etc.). Base `ggplot` does not have a convenient way to do this, so we are going to download a package, `ggsignif`, that adds a new **layer** to add significance brackets to a plot.

```{r}
install.packages("ggsignif")
library(ggsignif)
```


